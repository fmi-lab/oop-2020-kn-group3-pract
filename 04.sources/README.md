# Скриване на имплементацията

### Intro

* Един изкуствен пример, с който да упражните наученото от DynamicArray при управление на динамична памет с конструктори, деструктори и методи.

### Какво ново

* Ще ползвате `public` и `private` модификатори за видимост на член-данни и член-функции (методи)
* Ще видите как това е начин за гарантиране на валидността на обектите, които създавате

### Защо го правим

* За да освободим програмиста - самите нас, колегите или просто някой нещастен човек, който се бори с кода ви след година - от нуждата да мисли за детайли, пряко касаещи коректното функциониране на вашия код. 
* В нашия случай "детайлите" са правилното заделяне и освобождаване на паметта по време на работа с обекти на класове, написани от вас
* Глупав пример: пишете софтуер за управление на бойни дронове. Командният интерфейс на базата в ЦРУ, който комуникира с вашата програма, се грижи единствено за това да подава сигналите на пилота. Вашата задача е въртите перките с подходящата скорост, да зареждате оръдието и да приберете дрона на сигурно място при загуба на връзка с контролния център, като единствения интерфейс ([API](https://en.wikipedia.org/wiki/Application_programming_interface)), който предоставяте за работа с програмата ви, са функции от рода `MoveForward(speed)`, `FireAt(location),` `Rotate(angle)`.

### Вашата задача
* Създайте шаблонен клас Matrix<T> за работа с матрици с променлив размер с елементи от тип T. 
* Единствената публично достъпна функционалност трябва да бъдат следните методи:
    - Подходящи конструктори по ваш вкус
    - Деструктор, почистващ цялата памет, заделена по време на работа с инстанции на Matrix<T>
        - Защо трябва да бъде публичен? Не може ли да имате [private деструктор](https://stackoverflow.com/q/631783)?
    - Методи `size_t getWidth()` и `size_t getHeight()`, които връщат размерите на матрицата
    - Метод `const T& get(int row, int col)`, който връща референция към елемента на позиция *(row, col)*
    - Метод `void set(int row, int col)`, който задава нова стойност на елемента на позиция *(row, col)*
    - Методи `void addRow()` и `void addColumn()`, които разширяват матрицата в съответните посоки (със стойности по подразбиране за T)

### Упътване
1. Започнете със създаване на стрктура за числови матрици, оставете шаблоните за после
2. Направете структура, съдържаща променливи, описващи цялата нужна информация за една матрица:
    * брой колони и брой редове
    * указател `data` към паметта, в която живеят стойностите на клетките. Какъв е типът на `data`? Погледнете отново дефиницията DynamicArray - тук направете "указател към двумерен масив" (вместо към единичен `T* data`, както беше преди)
3. Направете конструктор без параметри, който инициализира с нули размера на матрицата и слага подходяща нулева стойност на указателя `data`.
    * Можете ли да зададете стойности по подразбиране на член-данните, и да оставите конструктора *празен*? Прочетете за [explicitly defaulted constructors](https://www.geeksforgeeks.org/explicitly-defaulted-deleted-functions-c-11/).
4. Имплементирайте функцията `addRow()`. Какво трябва да направи тя? 
    * Създайте нов масив с указатели към редовете, с един елемент по-дълъг от текущия - точно както го правихме в DynamicArray
    * В случая с DynamicArray новият елемент беше просто `T{}` (или, ако `T` е `int` - просто `0`). Тук какво ще трябва да запишете в `data[size]`?
    * Не забравяйте да почистите всичко, което няма да използвате повече!
5. Дефинирайте деструктор, който почиства цялата памет, използвана от Matrix.
    * Внимавайте! Какво трябва да изтриете? Колко `delete[]` операции трябва да се изпълнят?
6. На база примерите от лекции, превърнете структурата в клас
    * Оставете всичко останало private, а направете public гореизброените методи
7. Припомнете си как се правят шаблони - разгледайте последната версия на DynamicArray и превърнете готовия Matrix клас в шаблон.
